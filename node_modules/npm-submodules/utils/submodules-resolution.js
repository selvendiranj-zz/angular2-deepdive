"use strict";
// import { TsmOptions } from '../types';
const constants_1 = require("./constants");
const fs = require('fs');
const path = require('path');
const tsconfig = require('tsconfig');
const readPkg = require('read-pkg');
// todo: order by cross dependencies
// todo: add --use-local-dependencies alias --local
/**
 * Will try to find package.json in src folder
 * if not found will search in 1st level of directories
 * Returns list of directories with package.json
 * project - string, relative path to folder
 */
function findSubmodules(project, options) {
    return listDirs(project)
        .then(dirs => orderByCrossDeps(dirs
        .filter(dir => isModuleRoot(dir))
        .map(dir => ({ dir, tsconfig: tsconfig.loadSync(dir) }))
        .map(opt => resolveOptions(project, opt))));
}
exports.findSubmodules = findSubmodules;
function listDirs(project) {
    return Promise.resolve([project].concat(fs
        .readdirSync(path.resolve(project))
        .filter(file => fs.statSync(path.resolve(project, file))
        .isDirectory())
        .map(dir => path.join(project, dir))));
}
function isModuleRoot(dir) {
    if (fs.existsSync(path.join(dir, constants_1.pkgFileName))) {
        return !!tsconfig.resolveSync(dir);
    }
    return false;
}
function resolveOptions(project, opt) {
    const tsOutDir = opt.tsconfig.config.compilerOptions.outDir;
    const tsConfigDir = path.dirname(opt.tsconfig.path);
    const relTsOutDir = path.relative(constants_1.ROOT, path.resolve(tsConfigDir, tsOutDir));
    const moduleDir = path.relative(project, opt.dir);
    // tsc out dir
    const dist = relTsOutDir.indexOf(moduleDir) == -1
        ? path.join(relTsOutDir, moduleDir)
        : relTsOutDir;
    // submodule root
    const src = opt.dir;
    // tsconfig project
    return {
        src, dist,
        tsconfig: opt.tsconfig,
        project: path.relative(constants_1.ROOT, tsConfigDir),
        pkg: readPkg.sync(src)
    };
}
// todo: split it in
// 1. building cross dependencies
// 2. sorting by cross dependencies count
/**
 * */
function orderByCrossDeps(options) {
    const pkgName = options.map(opt => opt.pkg.name);
    return options
        .map(option => {
        option.cross = [];
        constants_1.dependencyKeys.forEach(depKey => {
            if (!option.pkg[depKey]) {
                return;
            }
            pkgName.forEach(name => {
                if (name in option.pkg[depKey]) {
                    option.cross.push(name);
                }
            });
        });
        return option;
    })
        .sort((a, b) => {
        if (a.cross.length === b.cross.length) {
            return 0;
        }
        return a.cross.length > b.cross.length ? 1 : -1;
    });
}
